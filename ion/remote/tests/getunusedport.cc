/**
Copyright 2017 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS-IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

#include "ion/remote/tests/getunusedport.h"

#if defined(ION_PLATFORM_WINDOWS)
#include <winsock2.h>
#include <Ws2ipdef.h>
typedef int socklen_t;
typedef SOCKET ion_socket_t;
namespace {
void close(ion_socket_t socket) {
  closesocket(socket);
}
}  // namespace
#else
#include <arpa/inet.h>
#include <sys/socket.h>
#include <unistd.h>
typedef int ion_socket_t;
#endif

#include "base/integral_types.h"
#include "ion/base/lockguards.h"
#include "ion/base/logging.h"
#include "ion/port/environment.h"
#include "ion/remote/portutils.h"
#if defined(ION_PLATFORM_LINUX) && defined(ION_GOOGLE_INTERNAL)
#include "net/util/ports.h"
#endif


namespace {

// Quick and dirty random number generator. See:
// http://www.orthogonal.com.au/hobby/random/index.htm
static float GetRandom() {
  // These seeds were chosen by mashing the numeric keypad.
  static int kSeed1 = 35768;
  static int kSeed2 = 7389243;

  // These were generated by mashing the numeric keys on the keyboard.
  int z, k;
  k = kSeed1 / 53668;
  kSeed1 = 40014 * (kSeed1 - k * 53668) - k * 12211;
  if (kSeed1 < 0) kSeed1 = kSeed1 + 2147483563;
  k = kSeed2 / 52774;
  kSeed2 = 40692 * (kSeed2 - k * 52774) - k * 3791;
  if (kSeed2 < 0) kSeed2 = kSeed2 + 2147483399;
  z = kSeed1 - kSeed2;
  if (z < 1) z = z + 2147483562;
  return static_cast<float>(z) * 4.65661305956E-10f;
}

// PortIterator implements the port selection order described in the comments
// for PickUnusedPort below. It is an iterator over the sequence of candidate
// ports:
//   1. a constant number of ports chosen randomly from [32768..60000]
//   2. zero, to let the OS decide.
class PortIterator {
 public:
  explicit PortIterator(int num_ports_to_try)
      : num_ports_to_try_(num_ports_to_try),
        random_port_count_(0),
        port_(-1),
        done_(false) {
    Next();
  }

  int GetPort() const {
    DCHECK(!done_);
    return port_;
  }

  bool Done() const {
    return done_;
  }

  void Next() {
    DCHECK(!done_);

    // For the first kNumRandomPortsToPick, pick a random port in the range
    // [kMinPort..kMaxPort] and check to see if it is available. If not, ask
    // the system to assign a port.
    if (random_port_count_ < num_ports_to_try_) {
      random_port_count_++;
      static const int kMinPort = 32768;
      static const int kMaxPort = 60000;
      port_ = kMinPort + static_cast<int>(GetRandom() * (kMaxPort - kMinPort));
    } else {
      // As a last attempt, we let the system assign a port (indicated by port
      // 0). If we have already tried port 0, the iterator is done.
      if (port_ == 0) {
        done_ = true;
      } else {
        port_ = 0;
      }
    }
  }

 private:
  int num_ports_to_try_;
  int random_port_count_;
  int port_;
  bool done_;
};

static bool IsPortAvailable(int* port, bool is_tcp) {
  DCHECK_GE(*port, 0);

  // For a port to be considered available, the kernel must support at least one
  // of (IPv6, IPv4), and the port must be available on each supported family.
  bool got_socket = false;
  for (int family : {AF_INET6, AF_INET}) {
    const int proto = is_tcp ? IPPROTO_TCP : 0;
    const ion_socket_t fd =
        socket(family, is_tcp ? SOCK_STREAM : SOCK_DGRAM, proto);
    if (fd != static_cast<ion_socket_t>(-1)) {
      got_socket = true;
    } else {
      continue;
    }

    // Reuseaddr lets us start up a server immediately after it exits.
    int one = 1;
    const char* options = reinterpret_cast<const char*>(&one);
    if (setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, options, sizeof(one)) < 0) {
      close(fd);
      return false;
    }

    // Try binding to *port.
    sockaddr_storage addr = ion::remote::MakeWildcard(family, *port);
    sockaddr* paddr = reinterpret_cast<sockaddr*>(&addr);
    // On Darwin the length must match the structure size;
    // sizeof(sockaddr_storage) leads to an invalid argument error.
    socklen_t alen = ion::remote::GetSockaddrLength(addr);
    if (::bind(fd, paddr, alen) < 0) {
      close(fd);
      return false;
    }

    // Get the bound port number.
    if (getsockname(fd, paddr, &alen) < 0) {
      close(fd);
      return false;
    }
    int actual_port = ion::remote::GetPort(addr);
    CHECK_GT(actual_port, 0);
    if (*port == 0) {
      *port = actual_port;
    } else {
      CHECK_EQ(*port, actual_port);
    }

    // Try listening on the port also, if the type is TCP.
    if (is_tcp) {
      if (listen(fd, 1) < 0) {
        close(fd);
        return false;
      }
    }

    close(fd);
  }

  if (!got_socket) {
    return false;
  }

  return true;
}

static int PickUnusedPort(int num_ports_to_try) {
#if defined(ION_GOOGLE_INTERNAL) && defined(ION_PLATFORM_LINUX)
  return net_util::PickUnusedPortOrDie();
#else
  // We repeatedly pick a port and then see whether or not it is
  // available for use both as a TCP socket and a UDP socket.  If some
  // unused ports have been assigned in the environment (by a test
  // runner, for example) use those first. For the next few
  // iterations, we pick a random large port number.  For subsequent
  // iterations, we bind to an anonymous port and let the OS pick the
  // port number.  The random port picking reduces the probability of
  // races with other processes on kernels that want to reuse the same
  // port numbers over and over.
  //
  // In alternating iterations we try UDP ports before TCP ports UDP
  // ports -- it could be the case that this machine has been using up
  // UDP ports and they are scarcer.
  //
  // Type of port to first pick in next iteration
  bool is_tcp = true;
  for (PortIterator iter(num_ports_to_try); !iter.Done(); iter.Next()) {
    int port = iter.GetPort();
    // Port 0 means the system picks a port.
    if (!IsPortAvailable(&port, is_tcp))
      continue;
    CHECK_GT(port, 0);
    if (!IsPortAvailable(&port, !is_tcp)) {
      // In the next iteration try to bind to the other type.
      is_tcp = !is_tcp;
      continue;
    }

    return port;
  }

  // The port iterator reached the end without finding a suitable port.
  LOG(ERROR) << "Could not find an open port after " << num_ports_to_try
             << " trials.";
  return 0;
#endif
}

}  // anonymous namespace

int ion::remote::testing::GetUnusedPort(int num_ports_to_try) {
#if defined(ION_PLATFORM_WINDOWS)
  WSADATA data;
  WSAStartup(MAKEWORD(2, 2), &data);
#endif
  const int port = PickUnusedPort(num_ports_to_try);
#if defined(ION_PLATFORM_WINDOWS)
  WSACleanup();
#endif
  return port;
}

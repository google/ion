/**
Copyright 2017 Google Inc. All Rights Reserved.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS-IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

// This is not a unit test - it uses OpenGL to render an ion scene graph in a
// window.

#include <memory>
#include <string>
#include <vector>

#include "ion/base/logging.h"
#include "ion/base/setting.h"
#include "ion/base/settingmanager.h"
#include "ion/base/stringutils.h"
#include "ion/base/zipassetmanager.h"
#include "ion/base/zipassetmanagermacros.h"
#include "ion/demos/utils.h"
#include "ion/demos/viewerdemobase.h"
#include "ion/gfx/attributearray.h"
#include "ion/gfx/bufferobject.h"
#include "ion/gfx/framebufferobject.h"
#include "ion/gfx/image.h"
#include "ion/gfx/indexbuffer.h"
#include "ion/gfx/node.h"
#include "ion/gfx/renderer.h"
#include "ion/gfx/sampler.h"
#include "ion/gfx/shaderinputregistry.h"
#include "ion/gfx/shaderprogram.h"
#include "ion/gfx/shape.h"
#include "ion/gfx/statetable.h"
#include "ion/gfx/texture.h"
#include "ion/gfx/uniform.h"
#include "ion/gfxutils/buffertoattributebinder.h"
#include "ion/gfxutils/frame.h"
#include "ion/gfxutils/shadermanager.h"
#include "ion/gfxutils/shadersourcecomposer.h"
#include "ion/gfxutils/shapeutils.h"
#include "ion/math/matrix.h"
#include "ion/math/range.h"
#include "ion/math/transformutils.h"
#include "ion/math/vector.h"
#include "ion/port/timer.h"

ION_REGISTER_ASSETS(IonParticlesShaders);

using ion::math::Matrix4f;
using ion::math::Point2f;
using ion::math::Point2i;
using ion::math::Point3f;
using ion::math::Range1i;
using ion::math::Range2i;
using ion::math::Vector2f;
using ion::math::Vector2i;
using ion::math::Vector3f;
using ion::math::Vector4f;

// Global vars.
static ion::gfx::FramebufferObjectPtr s_fbo;
static ion::gfx::NodePtr s_plane;
static ion::gfx::TexturePtr s_plane_texture;
static ion::gfx::NodePtr s_flying_particles;
static ion::gfx::NodePtr s_hud;
static ion::port::Timer* s_timer = nullptr;
static ion::gfx::BufferObjectPtr s_particles_buffer_object;
static const int kHudWidth  = 128;
static const int kHudHeight = 128;
static const int kFboWidth  = 256;
static const int kFboHeight = 256;

// User controls.
static ion::base::Setting<float> s_min_height(
    "particles/static/min height", 30.f, "Minimum particle height");
static ion::base::Setting<float> s_height_range(
    "particles/static/height range", 20.f, "Particle height range");
static ion::base::Setting<bool> s_sampling_mode_square(
    "particles/static/sampling mode square", true,
    "Sample with a square or circle");
static bool s_rebuild_particles = false;

//-----------------------------------------------------------------------------
//
// Shape construction.
//
//-----------------------------------------------------------------------------

struct Vertex {
  Vector3f point_coords;
  Vector2f tex_coords;
};

struct Particle {
  Vector3f velocity;
  Vector3f color;
  Vector2f offset_length;
};

// Particle colors: the official Google colors.
static const Vector3f google_colors[] = {
  Vector3f(51.f  / 255.f, 105.f / 255.f, 232.f / 255.f),  // Blue
  Vector3f(213.f / 255.f, 15.f  / 255.f, 37.f  / 255.f),  // Red
  Vector3f(238.f / 255.f, 178.f / 255.f, 17.f  / 255.f),  // Yellow
  Vector3f(0.f   / 255.f, 153.f / 255.f, 37.f  / 255.f),  // Green
};

static const int kNumColors =
    static_cast<int>(sizeof(google_colors) / sizeof(Vector3f));

// Quick and dirty random number generator.
// Blatently stolen from http://www.orthogonal.com.au/hobby/random/index.htm
static int s1 = 2378654;
static int s2 = 76543;
static void ResetRandom() {
  s1 = 2378654;
  s2 = 76543;
}
static float GetRandom() {
  // These were generated by mashing the numeric keys on the keyboard.
  int z, k;
  k = s1 / 53668;
  s1 = 40014 * (s1 - k * 53668) - k * 12211;
  if (s1 < 0) s1 = s1 + 2147483563;
  k = s2 / 52774;
  s2 = 40692 * (s2 - k * 52774) - k * 3791;
  if (s2 < 0) s2 = s2 + 2147483399;
  z = s1 - s2;
  if (z < 1) z = z + 2147483562;
  return static_cast<float>(z) * 4.65661305956E-10f;
}

//-----------------------------------------------------------------------------
//
// Texture image construction.
//
//-----------------------------------------------------------------------------

static ion::gfx::ImagePtr BuildTextureImage() {
  static const int kWidth = 54;
  static const int kHeight = 57;
  static const int kRowSize = kWidth * 3;

  static const float float_pixels[kWidth* kHeight] = {
#include "ion/demos/spark-54x57.h"
  };

  uint8 pixels[kHeight * kRowSize];
  for (int y = 0; y < kHeight; y++) {
    for (int x = 0; x < kWidth; x++) {
      float intensity = float_pixels[y * kWidth + x];
      unsigned char value = static_cast<unsigned char>(
          std::min(std::max(intensity * 255.f, 0.f), 255.f));
      pixels[3 * (y * kWidth + x)] = pixels[3 * (y * kWidth + x) + 1] =
          pixels[3 * (y * kWidth + x) + 2] = value;
    }
  }

  ion::gfx::ImagePtr image(new ion::gfx::Image);
  ion::base::DataContainerPtr container =
      ion::base::DataContainer::CreateAndCopy<uint8>(
          pixels, kHeight * kRowSize, true, image->GetAllocator());

  image->Set(ion::gfx::Image::kRgb888, kWidth, kHeight, container);
  return image;
}

//-----------------------------------------------------------------------------
//
// Shape construction.
//
//-----------------------------------------------------------------------------

// Builds a set of particles with random initial directions, velocities, and
// colors.
static ion::gfx::BufferObjectPtr BuildParticlesBufferObject(
    size_t particle_count) {
  Particle* particles;
  particles = new Particle[particle_count];
  ResetRandom();
  for (size_t i = 0; i < particle_count; ++i) {
    float speed = GetRandom();
    float height = s_min_height + s_height_range * GetRandom();
    if (s_sampling_mode_square) {
      // Square sampling.
      float dirx = GetRandom();
      float dirz = GetRandom();
      particles[i].velocity.Set(speed * (2.f * dirx - 1.f), height,
                                speed * (2.f * dirz - 1.f));
    } else {
      float dir = GetRandom();
      // Disk sampling.
      static const float kPi = static_cast<float>(M_PI);
      particles[i].velocity.Set(speed * cosf(2.f * kPi * dir), height,
                                speed * sinf(2.f * kPi * (1.f - dir)));
    }
    particles[i].color = google_colors[i % kNumColors];
    float start_offset = GetRandom() *
        ((s_min_height + s_height_range) * 0.1f + 5.f);  // In seconds.
    // Inverse length of the simulation, in seconds.
    float inverse_length = 1.f / (height * .1f + GetRandom() * 5.f);
    particles[i].offset_length.Set(start_offset, inverse_length);
  }

  if (s_particles_buffer_object.Get() == nullptr)
    s_particles_buffer_object.Reset(new ion::gfx::BufferObject);
  // This will destroy the old data.
  ion::base::DataContainerPtr container =
      ion::base::DataContainer::Create<Particle>(
          particles, ion::base::DataContainer::ArrayDeleter<Particle>, true,
          s_particles_buffer_object->GetAllocator());
  // The old data will be destroyed.
  s_particles_buffer_object->SetData(
      container, sizeof(particles[0]), particle_count,
      ion::gfx::BufferObject::kStaticDraw);
  return s_particles_buffer_object;
}

static ion::gfx::ShapePtr BuildParticlesShape() {
  ion::gfx::ShapePtr shape(new ion::gfx::Shape);
  shape->SetLabel("Particles");
  shape->SetPrimitiveType(ion::gfx::Shape::kPoints);
  return shape;
}

//-----------------------------------------------------------------------------
//
// Scene graph construction.
//
//-----------------------------------------------------------------------------

static const ion::gfx::NodePtr BuildRectangle(
    const ion::gfxutils::ShaderManagerPtr& shader_manager,
    const Vector4f& color) {
  ion::gfx::ShaderInputRegistryPtr reg(
      new ion::gfx::ShaderInputRegistry);
  reg->IncludeGlobalRegistry();
  reg->Add(ion::gfx::ShaderInputRegistry::UniformSpec(
      "uTexture", ion::gfx::kTextureUniform, "Plane texture"));

  ion::gfx::NodePtr node(new ion::gfx::Node);
  node->SetLabel("Rectangle");
  demoutils::AddUniformToNode(reg, "uTexture", s_plane_texture, node);


  node->SetShaderProgram(shader_manager->CreateShaderProgram(
      "Plane shader",
      reg,
      ion::gfxutils::ShaderSourceComposerPtr(
          new ion::gfxutils::ZipAssetComposer("plane.vp", false)),
      ion::gfxutils::ShaderSourceComposerPtr(
          new ion::gfxutils::ZipAssetComposer("plane.fp", false))));

  ion::gfxutils::RectangleSpec rect_spec;
  rect_spec.vertex_type = ion::gfxutils::ShapeSpec::kPositionTexCoords;
  rect_spec.plane_normal = ion::gfxutils::RectangleSpec::kNegativeY;
  rect_spec.translation.Set(0.f, -0.1f, 0.f);
  rect_spec.size.Set(20.f, 20.f);
  node->AddShape(ion::gfxutils::BuildRectangleShape(rect_spec));

  return node;
}

static const ion::gfx::NodePtr BuildParticles(
    const ion::gfxutils::ShaderManagerPtr& shader_manager,
    const std::string& shader_name, const std::string& vertex_name,
    const std::string& fragment_name, size_t particle_count) {
  ion::gfx::ShaderInputRegistryPtr reg(
      new ion::gfx::ShaderInputRegistry);
  reg->IncludeGlobalRegistry();
  reg->Add(ion::gfx::ShaderInputRegistry::UniformSpec(
      "uTime", ion::gfx::kFloatUniform, "The current animation time"));
  reg->Add(ion::gfx::ShaderInputRegistry::UniformSpec(
      "uExposure", ion::gfx::kFloatUniform, "Color exposure"));
  reg->Add(ion::gfx::ShaderInputRegistry::UniformSpec(
      "uPointSize", ion::gfx::kFloatUniform, "Particle point size"));
  reg->Add(ion::gfx::ShaderInputRegistry::UniformSpec(
      "uViewport", ion::gfx::kFloatVector4Uniform, "Viewport information"));
  reg->Add(ion::gfx::ShaderInputRegistry::UniformSpec(
      "uSprite", ion::gfx::kTextureUniform, "Sprite texture"));
  reg->Add(ion::gfx::ShaderInputRegistry::AttributeSpec(
      "aVelocity", ion::gfx::kBufferObjectElementAttribute,
      "The velocity of the particle"));
  reg->Add(ion::gfx::ShaderInputRegistry::AttributeSpec(
      "aOffsetLength", ion::gfx::kBufferObjectElementAttribute,
      "The time offset of the particle and its animation length"));

  ion::gfx::NodePtr node(new ion::gfx::Node);
  demoutils::AddUniformToNode(reg, "uTime", 0.f, node);
  demoutils::AddUniformToNode(reg, "uExposure", 1.5f, node);
  demoutils::AddUniformToNode(reg, "uViewport",
                              Vector4f(0.f, 0.f, 0.f, 0.f), node);
  demoutils::AddUniformToNode(reg, "uPointSize", 32.f, node);

  ion::gfx::TexturePtr texture(new ion::gfx::Texture);
  texture->SetImage(0U, BuildTextureImage());
  ion::gfx::SamplerPtr sampler(new ion::gfx::Sampler);
  texture->SetSampler(sampler);
  sampler->SetMinFilter(ion::gfx::Sampler::kLinear);
  sampler->SetMagFilter(ion::gfx::Sampler::kLinear);
  // This is required for textures on iOS. No other texture wrap mode seems to
  // be supported.
  sampler->SetWrapS(ion::gfx::Sampler::kClampToEdge);
  sampler->SetWrapT(ion::gfx::Sampler::kClampToEdge);
  demoutils::AddUniformToNode(reg, "uSprite", texture, node);

  ion::gfx::AttributeArrayPtr attribute_array(new ion::gfx::AttributeArray);
  if (!s_particles_buffer_object.Get())
    s_particles_buffer_object = BuildParticlesBufferObject(particle_count);
  Particle p;
  ion::gfxutils::BufferToAttributeBinder<Particle>(p)
      .Bind(p.color, "aColor")
      .Bind(p.offset_length, "aOffsetLength")
      .Bind(p.velocity, "aVelocity")
      .Apply(reg, attribute_array, s_particles_buffer_object);
  ion::gfx::ShaderProgramPtr shader =
      shader_manager->CreateShaderProgram(
          shader_name, reg, ion::gfxutils::ShaderSourceComposerPtr(
              new ion::gfxutils::ZipAssetComposer(vertex_name, false)),
          ion::gfxutils::ShaderSourceComposerPtr(
              new ion::gfxutils::ZipAssetComposer(fragment_name, false)));
  node->SetShaderProgram(shader);

  // reg now points to nullptr since the shader owns it.
  ion::gfx::ShapePtr shape = BuildParticlesShape();
  shape->SetAttributeArray(attribute_array);

  node->AddShape(shape);

  return node;
}

static const ion::gfx::NodePtr BuildGraph(
    const ion::gfxutils::ShaderManagerPtr& shader_manager,
    int width, int height, size_t particle_count) {
  ion::gfx::NodePtr root(new ion::gfx::Node);
  root->SetLabel("Root");

  // Set up global state.
  ion::gfx::StateTablePtr state_table(new ion::gfx::StateTable(width, height));
  state_table->SetViewport(
      Range2i::BuildWithSize(Point2i(0, 0), Vector2i(width, height)));
  state_table->SetClearColor(Vector4f(0.3f, 0.3f, 0.5f, 1.0f));
  state_table->SetClearDepthValue(1.f);
  state_table->Enable(ion::gfx::StateTable::kBlend, true);
  state_table->Enable(ion::gfx::StateTable::kCullFace, false);
  state_table->SetBlendFunctions(ion::gfx::StateTable::kOne,
                                 ion::gfx::StateTable::kOneMinusSrcColor,
                                 ion::gfx::StateTable::kOne,
                                 ion::gfx::StateTable::kOneMinusSrcAlpha);
  root->SetStateTable(state_table);

  s_flying_particles = BuildParticles(
      shader_manager, "flying_particle shader", "flying.vp", "flying.fp",
      particle_count);
  s_flying_particles->SetLabel("Main Particles");
  // Floor rectangle.
  root->AddChild(s_plane);
  root->AddChild(s_flying_particles);

  return root;
}

static const ion::gfx::NodePtr BuildFboGraph(
    const ion::gfxutils::ShaderManagerPtr& shader_manager,
    int width, int height, size_t particle_count) {
  const ion::gfx::ShaderInputRegistryPtr& global_reg =
      ion::gfx::ShaderInputRegistry::GetGlobalRegistry();

  ion::gfx::NodePtr root = BuildParticles(
      shader_manager, "capture_particle shader", "capture.vp", "capture.fp",
      particle_count);
  root->SetLabel("FBO Particles Root");
  const Matrix4f fbo_proj = ion::math::OrthographicMatrixFromFrustum(
      -10.f, 10.f, -10.f, 10.f, -1.f, 1.f);

  demoutils::AddUniformToNode(global_reg, "uProjectionMatrix", fbo_proj, root);
  // Set up global state.
  ion::gfx::StateTablePtr state_table(new ion::gfx::StateTable(width, height));
  state_table->SetViewport(
      Range2i::BuildWithSize(Point2i(0, 0), Vector2i(width, height)));
  state_table->SetClearColor(Vector4f(.125f, .125f, .125f, 0.f));
  state_table->Enable(ion::gfx::StateTable::kBlend, true);
  state_table->SetBlendFunctions(ion::gfx::StateTable::kOne,
                                 ion::gfx::StateTable::kOneMinusSrcColor,
                                 ion::gfx::StateTable::kOne,
                                 ion::gfx::StateTable::kOneMinusSrcAlpha);
  root->SetStateTable(state_table);

  return root;
}

static const ion::gfx::NodePtr BuildHudGraph(int width, int height) {
  const ion::gfx::ShaderInputRegistryPtr& global_reg =
      ion::gfx::ShaderInputRegistry::GetGlobalRegistry();

  ion::gfx::NodePtr hud(new ion::gfx::Node);
  hud->SetLabel("HUD Root");
  ion::gfx::StateTablePtr state_table(new ion::gfx::StateTable(width, height));
  state_table->SetViewport(
      Range2i::BuildWithSize(Point2i(600, 0), Vector2i(width, height)));
  state_table->Enable(ion::gfx::StateTable::kBlend, true);
  state_table->SetBlendFunctions(ion::gfx::StateTable::kOne,
                                 ion::gfx::StateTable::kOneMinusSrcColor,
                                 ion::gfx::StateTable::kOne,
                                 ion::gfx::StateTable::kOneMinusSrcAlpha);
  hud->SetStateTable(state_table);
  hud->AddChild(s_plane);
  const Matrix4f proj = ion::math::OrthographicMatrixFromFrustum(
      -10.f, 10.f, -10.f, 10.f, -1.f, 1.f);

  const Matrix4f view = ion::math::RotationMatrixAxisAngleH(
      Vector3f::AxisX(), ion::math::Anglef::FromDegrees(90.f));

  demoutils::AddUniformToNode(global_reg, "uProjectionMatrix", proj, hud);
  demoutils::AddUniformToNode(global_reg, "uModelviewMatrix", view, hud);
  return hud;
}

static void UpdateParticles(ion::base::SettingBase* setting) {
  s_rebuild_particles = true;
}

//-----------------------------------------------------------------------------
//
// Particles class.
//
//-----------------------------------------------------------------------------

class IonParticlesDemo : public ViewerDemoBase {
 public:
  IonParticlesDemo(int width, int height);
  ~IonParticlesDemo() override;
  void Resize(int width, int height) override;
  void Update() override;
  void RenderFrame() override;
  void Keyboard(int key, int x, int y, bool is_press) override {}
  std::string GetDemoClassName() const override { return "Particles"; }

 private:
  ion::gfx::NodePtr root_;
  ion::gfx::NodePtr plane_particles_;

  ion::base::Setting<float> point_size_;
  ion::base::Setting<float> time_factor_;
  ion::base::Setting<size_t> particle_count_;
  ion::base::Setting<float> exposure_;
};

IonParticlesDemo::IonParticlesDemo(int width, int height)
    : ViewerDemoBase(width, height),
      point_size_("particles/point size", 32.f, "Particle size"),
      time_factor_("particles/time factor", .00075f, "Simulation time scale"),
      particle_count_("particles/particle count", 2000U, "Number of particles"),
      exposure_("particles/exposure", 1.5f, "Particle exposure") {
  // Load shader assets.
  IonParticlesShaders::RegisterAssets();

  particle_count_.RegisterListener("Particles", UpdateParticles);
  ion::base::SettingManager::RegisterGroupListener(
      "particles/static", "Particles", UpdateParticles);

  ion::gfx::ImagePtr image(new ion::gfx::Image);
  image->Set(ion::gfx::Image::kRgba8888, kFboWidth, kFboHeight,
             ion::base::DataContainerPtr(nullptr));
  s_plane_texture = new ion::gfx::Texture();
  ion::gfx::SamplerPtr sampler(new ion::gfx::Sampler);
  s_plane_texture->SetSampler(sampler);
  sampler->SetMinFilter(ion::gfx::Sampler::kLinear);
  sampler->SetMagFilter(ion::gfx::Sampler::kLinear);
  // This is required for textures on iOS. No other texture wrap mode seems to
  // be supported.
  sampler->SetWrapS(ion::gfx::Sampler::kClampToEdge);
  sampler->SetWrapT(ion::gfx::Sampler::kClampToEdge);
  s_plane_texture->SetImage(0U, image);
  s_plane = BuildRectangle(GetShaderManager(),
                           Vector4f(0.25f, 0.25f, 0.25f, 1.0f));

  // 
  s_fbo = new ion::gfx::FramebufferObject(kFboWidth, kFboHeight);
  s_fbo->SetColorAttachment(
      0U, ion::gfx::FramebufferObject::Attachment(s_plane_texture));
  s_fbo->SetLabel("FBO");
  root_ = BuildGraph(GetShaderManager(), width, height, particle_count_);
  plane_particles_ = BuildFboGraph(GetShaderManager(), kFboWidth, kFboHeight,
                                   particle_count_);
  s_hud = BuildHudGraph(kHudWidth, kHudHeight);

  // Set up viewing.
  SetTrackballRadius(15.0f);
  SetNodeWithViewUniforms(root_);
  UpdateViewUniforms();

  s_timer = new ion::port::Timer;

  // Set up the remote handlers.
  std::vector<ion::gfx::NodePtr> tracked_nodes;
  tracked_nodes.push_back(root_);
  tracked_nodes.push_back(plane_particles_);
  tracked_nodes.push_back(s_hud);
  InitRemoteHandlers(tracked_nodes);
}

IonParticlesDemo::~IonParticlesDemo() {
  s_fbo.Reset(nullptr);
  s_plane.Reset(nullptr);
  s_plane_texture.Reset(nullptr);
  s_flying_particles.Reset(nullptr);
  s_hud.Reset(nullptr);
  delete s_timer;
  s_particles_buffer_object.Reset(nullptr);
}

void IonParticlesDemo::Resize(int width, int height) {
  ViewerDemoBase::Resize(width, height);

  root_->GetStateTable()->SetViewport(
      Range2i::BuildWithSize(Point2i(0, 0), Vector2i(width, height)));
  s_hud->GetStateTable()->SetViewport(
      Range2i::BuildWithSize(Point2i(width - kHudWidth - 50, 50),
                             Vector2i(kHudWidth, kHudHeight)));
}

void IonParticlesDemo::Update() {
  static float s_last_time = 0;
  static float s_time = 0.f;
  const float current_time = static_cast<float>(s_timer->GetInMs());
  s_time += (current_time - s_last_time) * time_factor_;
  s_last_time = current_time;

  // Rebuild particles if requested.
  if (s_rebuild_particles) {
    s_rebuild_particles = false;
    BuildParticlesBufferObject(particle_count_);
    s_flying_particles = BuildParticles(
        GetShaderManager(), "flying_particle shader", "flying.vp", "flying.fp",
        particle_count_);
    s_flying_particles->SetLabel("Main Particles");
    root_->ClearChildren();
    root_->AddChild(s_plane);
    root_->AddChild(s_flying_particles);
  }

  // Update the simulation time and exposure.
  demoutils::SetUniformInNode(0, s_time, s_flying_particles);
  demoutils::SetUniformInNode(0, s_time, plane_particles_);
  demoutils::SetUniformInNode(1, exposure_, s_flying_particles);
  demoutils::SetUniformInNode(1, exposure_, plane_particles_);

  const float width = static_cast<float>(GetViewportSize()[0]);
  const float height = static_cast<float>(GetViewportSize()[1]);
  Vector4f viewport(1.f / width, 1.f / height, width / point_size_,
                    height / point_size_);
  demoutils::SetUniformInNode(2, viewport, s_flying_particles);
  demoutils::SetUniformInNode(3, point_size_, s_flying_particles);
}

void IonParticlesDemo::RenderFrame() {
  const ion::gfx::RendererPtr& renderer = GetRenderer();
  // Draw to fbo.
  renderer->BindFramebuffer(s_fbo);
  renderer->DrawScene(plane_particles_);
  renderer->BindFramebuffer(ion::gfx::FramebufferObjectPtr());

  renderer->DrawScene(root_);
  renderer->DrawScene(s_hud);
}

std::unique_ptr<DemoBase> CreateDemo(int width, int height) {
  return std::unique_ptr<DemoBase>(new IonParticlesDemo(width, height));
}
